<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>General API · BayesDensity.jl</title><meta name="title" content="General API · BayesDensity.jl"/><meta property="og:title" content="General API · BayesDensity.jl"/><meta property="twitter:title" content="General API · BayesDensity.jl"/><meta name="description" content="Documentation for BayesDensity.jl."/><meta property="og:description" content="Documentation for BayesDensity.jl."/><meta property="twitter:description" content="Documentation for BayesDensity.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="BayesDensity.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">BayesDensity.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../density_estimation_primer/">A primer on Bayesian nonparametric density estimation</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>General API</a><ul class="internal"><li><a class="tocitem" href="#Defining-models"><span>Defining models</span></a></li><li><a class="tocitem" href="#Markov-chain-Monte-Carlo"><span>Markov chain Monte Carlo</span></a></li><li><a class="tocitem" href="#Variational-inference"><span>Variational inference</span></a></li></ul></li><li><a class="tocitem" href="../plotting_api/">Plotting API</a></li></ul></li><li><span class="tocitem">Methods</span><ul><li><a class="tocitem" href="../../methods/">Index</a></li><li><a class="tocitem" href="../../methods/BSplineMixture/">BSplineMixture</a></li><li><a class="tocitem" href="../../methods/HistSmoother/">HistSmoother</a></li><li><a class="tocitem" href="../../methods/PitmanYorMixture/">PitmanYorMixture</a></li><li><a class="tocitem" href="../../methods/FiniteGaussianMixture/">FiniteGaussianMixture</a></li><li><a class="tocitem" href="../../methods/RandomFiniteGaussianMixture/">RandomFiniteGaussianMixture</a></li><li><a class="tocitem" href="../../methods/RandomBernsteinPoly/">RandomBernsteinPoly</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/add_new_models/">Implementing new Bayesian density estimators</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>General API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>General API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/oskarhs/BayesDensity.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/oskarhs/BayesDensity.jl/blob/main/docs/src/api/general_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="General-API"><a class="docs-heading-anchor" href="#General-API">General API</a><a id="General-API-1"></a><a class="docs-heading-anchor-permalink" href="#General-API" title="Permalink"></a></h1><p>This page explains how to fit the Bayesian density models implemented in <code>BayesDensity.jl.</code> Most of the methods implemented in this package support two modes of posterior inference: simulation consistent inference through Markov chain Monte Carlo (MCMC) and approximate through variational inference (VI). We also document most of the convenience methods available for computing select posterior quantities of interest, such as the posterior mean or quantiles of <span>$f(t)$</span> for some <span>$t \in \mathbb{R}$</span>.</p><p>The plotting API of this package is documented on a <a href="../plotting_api/">separate page</a></p><h2 id="Defining-models"><a class="docs-heading-anchor" href="#Defining-models">Defining models</a><a id="Defining-models-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-models" title="Permalink"></a></h2><p>The first step to estimating a density with this package is to create a model object for which posterior inference is desired. All density models in this package are subtypes of <code>AbstractBayesDensityModel</code>:</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.AbstractBayesDensityModel"><a class="docstring-binding" href="#BayesDensityCore.AbstractBayesDensityModel"><code>BayesDensityCore.AbstractBayesDensityModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractBayesDensityModel{T&lt;:Real}</code></pre><p>Abstract super type for all Bayesian density models implemented in this package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L15-L19">source</a></section></details></article><p>In order to create a model object, we call the corresponding contructor with the data and other positional- and keyword arguments. For example, we can create a <a href="../../methods/BSplineMixture/#BSplineMixture"><code>BSplineMixture</code></a> object with default hyperparameters as follows:</p><pre><code class="language-julia hljs">bsm = BSplineMixture(randn(1000))</code></pre><p>For more detailed information on the arguments supported by each specific Bayesian density model we refer the reader to the <a href="../../methods/">methods documentation</a>.</p><h3 id="Evaluating-the-density-and-the-cumulative-distribution-function"><a class="docs-heading-anchor" href="#Evaluating-the-density-and-the-cumulative-distribution-function">Evaluating the density and the cumulative distribution function</a><a id="Evaluating-the-density-and-the-cumulative-distribution-function-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluating-the-density-and-the-cumulative-distribution-function" title="Permalink"></a></h3><p>The density estimators implemented in this package all specify a model <span>$f(t\,|\, \boldsymbol{\eta})$</span> for the density of the data, which depends on a parameter <span>$\boldsymbol{\eta}$</span>. In order to calculate <span>$f(\cdot)$</span> for a given <span>$\boldsymbol{\eta}$</span>, each Bayesian density model implements the <code>pdf</code> method.</p><article><details class="docstring" open="true"><summary id="Distributions.pdf-Tuple{AbstractBayesDensityModel, Any, Real}"><a class="docstring-binding" href="#Distributions.pdf-Tuple{AbstractBayesDensityModel, Any, Real}"><code>Distributions.pdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pdf(
    bdm::AbstractBayesDensityModel,
    parameters::NamedTuple,
    t::Union{Real, AbstractVector{&lt;:Real}}
) -&gt; Union{Real, Vector{&lt;:Real}}

pdf(
    bdm::AbstractBayesDensityModel,
    parameters::AbstractVector{&lt;:NamedTuple},
    t::Union{Real, AbstractVector{&lt;:Real}}
) -&gt; Matrix{&lt;:Real}</code></pre><p>Evaluate <span>$f(t \,|\,\boldsymbol{\eta})$</span> of the Bayesian density model <code>bdm</code> for every <span>$\boldsymbol{\eta}$</span> in <code>parameters</code> and every element in the collection <code>t</code>.</p><p>If a single NamedTuple is passed to the parameters argument, this function outputs either a scalar or a vector depending on the input type of the third argument <code>t</code>.</p><p>If a vector of NamedTuples is passed to the second positional argument, then this function returns a Matrix of size <code>(length(t), length(parameters))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L49-L67">source</a></section></details></article><p>For models that only implement the signature <code>pdf(::AbstractBayesDensityModel, ::Any, ::Real)</code>, a generic fallback method is provided for vectors of parameters and vector evaluation grids. However, it is recommended that most models provide specialized methods for vectors of parameters and vectors of evaluation points, as it is often possible to implement batch evaluation more efficiently (e.g. by leveraging BLAS calls instead of loops) when the parameters and the evaluation grid are provided in batches.</p><p>The cumulative distribution function of a model can be computed in a similar way by using the <code>cdf</code> method:</p><article><details class="docstring" open="true"><summary id="Distributions.cdf-Tuple{AbstractBayesDensityModel, Any, Real}"><a class="docstring-binding" href="#Distributions.cdf-Tuple{AbstractBayesDensityModel, Any, Real}"><code>Distributions.cdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cdf(
    bdm::AbstractBayesDensityModel,
    parameters::NamedTuple,
    t::Union{Real, AbstractVector{&lt;:Real}}
) -&gt; Union{Real, Vector{&lt;:Real}}

cdf(
    bdm::AbstractBayesDensityModel,
    parameters::AbstractVector{&lt;:NamedTuple},
    t::Union{Real, AbstractVector{&lt;:Real}}
) -&gt; Matrix{&lt;:Real}</code></pre><p>Evaluate the cumulative distribution function <span>$F(t\,|\, \boldsymbol{\eta}) = \int_{-\infty}^t f(s\,|\,\boldsymbol{\eta})\,\text{d}s$</span> of the Bayesian density model <code>bdm</code> for every <span>$\boldsymbol{\eta}$</span> in <code>parameters</code> and every element in the collection <code>t</code>.</p><p>If a single NamedTuple is passed to the parameters argument, this function outputs either a scalar or a vector depending on the input type of the third argument <code>t</code>.</p><p>If a vector of NamedTuples is passed to the second positional argument, then this function returns a Matrix of size <code>(length(t), length(parameters))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L72-L90">source</a></section></details></article><p>Generic fallback methods for computing the cdf for vectors of parameters and vector evaluation grids are also provided for models that implement the signature <code>cdf(::AbstractBayesDensityModel, ::Any, ::Real)</code>.</p><h3 id="Other-methods"><a class="docs-heading-anchor" href="#Other-methods">Other methods</a><a id="Other-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-methods" title="Permalink"></a></h3><p>All of the density models implemented in this package depend on the choice of various hyperparameters, which can be retrieved by utilizing the following method:</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.hyperparams-Tuple{AbstractBayesDensityModel}"><a class="docstring-binding" href="#BayesDensityCore.hyperparams-Tuple{AbstractBayesDensityModel}"><code>BayesDensityCore.hyperparams</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hyperparams(bdm::AbstractBayesDensityModel) -&gt; @NamedTuple</code></pre><p>Return the hyperparameters of the model <code>bdm</code> as a <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L31-L35">source</a></section></details></article><p>For the exact format of the returned hyperparameters for a specific Bayesian density model type, we refer to the docs of the individual density estimators.</p><p>To compute the support of a given model, the <code>support</code> method is provided.</p><article><details class="docstring" open="true"><summary id="Distributions.support-Union{Tuple{AbstractBayesDensityModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Distributions.support-Union{Tuple{AbstractBayesDensityModel{T}}, Tuple{T}} where T"><code>Distributions.support</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">support(bdm::AbstractBayesDensityModel{T}) where {T} -&gt; NTuple{2, T}</code></pre><p>Return the support of the model <code>bdm</code> as an 2-dimensional tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L40-L44">source</a></section></details></article><p>The element type of the model object can be determined via the <code>eltype</code> method:</p><article><details class="docstring" open="true"><summary id="Base.eltype-Union{Tuple{AbstractBayesDensityModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.eltype-Union{Tuple{AbstractBayesDensityModel{T}}, Tuple{T}} where T"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eltype(::AbstractBayesDensityModel{T}) where {T}</code></pre><p>Return the element type of a Bayesian density model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L24-L28">source</a></section><section><div><pre><code class="language-julia hljs">eltype(::PosteriorSamples{T}) where {T}</code></pre><p>Get the element type of a <code>PosteriorSamples</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L52-L56">source</a></section><section><div><pre><code class="language-julia hljs">eltype(::AbstractVIPosterior{T}) where {T}</code></pre><p>Get the element type of a variational posterior object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L21-L25">source</a></section></details></article><p>The following function is used to select a grid used for plotting of fitted model objects. A default fallback is provided, but it may be necessary to overload this method when implementing new models in order to make plotting functions work without having to supply an explicit grid of values for the first coordinate axis.</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.default_grid_points"><a class="docstring-binding" href="#BayesDensityCore.default_grid_points"><code>BayesDensityCore.default_grid_points</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">default_grid_points(bdm::AbstractBayesDensityModel{T}) where {T} -&gt; AbstractVector{T}</code></pre><p>Get the default grid used for plotting of density estimates.</p><p>Defaults to returning constructing a grid based on the extrema of <code>bdm.data.x</code>. If a given struct does not store a copy of the original data used to construct the model object as <code>bdm.data.x</code>, this method should be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L135-L142">source</a></section></details></article><h2 id="Markov-chain-Monte-Carlo"><a class="docs-heading-anchor" href="#Markov-chain-Monte-Carlo">Markov chain Monte Carlo</a><a id="Markov-chain-Monte-Carlo-1"></a><a class="docs-heading-anchor-permalink" href="#Markov-chain-Monte-Carlo" title="Permalink"></a></h2><p>The main workhorse of MCMC-based inference is the <code>sample</code> method, which takes a Bayesian density model object as input and generates posterior samples through a specialized MCMC routine.</p><article><details class="docstring" open="true"><summary id="StatsBase.sample-Tuple{AbstractBayesDensityModel, Int64}"><a class="docstring-binding" href="#StatsBase.sample-Tuple{AbstractBayesDensityModel, Int64}"><code>StatsBase.sample</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample(
    [rng::Random.AbstractRNG],
    bdm::AbstractBayesDensityModel{T},
    n_samples::Int
    args...;
    [n_burnin::Int],
    kwargs...
) where {T} -&gt; PosteriorSamples{T}</code></pre><p>Generate approximate posterior samples from the density model <code>bdm</code> using Markov chain Monte Carlo methods.</p><p>This functions returns a <a href="#BayesDensityCore.PosteriorSamples"><code>PosteriorSamples</code></a> object which can be used to compute posterior quantities of interest such as the posterior mean of <span>$f(t)$</span> or posterior quantiles. See the specific method docstring for method-specific additional positional and keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Seed used for random variate generation.</li><li><code>bdm</code>: The Bayesian density model object to generate posterior samples from.</li><li><code>n_samples</code>: Number of Monte Carlo samples (including burn-in)</li><li><code>args...</code>: Other model-specific positional arguments. See the specific model docstring for this method for further details.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>n_burnin</code>: Number of burn-in samples.</li><li><code>kwargs...</code>: Other model-specific kwargs. See the specific model docstring for this method for further details.</li></ul><p><strong>Returns</strong></p><ul><li><code>ps</code>: A <a href="#BayesDensityCore.PosteriorSamples"><code>PosteriorSamples</code></a> object holding the posterior samples and the original model object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L98-L125">source</a></section></details></article><p>All of the implemented MCMC methods return an object of type <code>PosteriorSamples</code>:</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.PosteriorSamples"><a class="docstring-binding" href="#BayesDensityCore.PosteriorSamples"><code>BayesDensityCore.PosteriorSamples</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PosteriorSamples{T&lt;:Real}</code></pre><p>Struct holding posterior samples of the parameters of a Bayesian density model.</p><p><strong>Fields</strong></p><ul><li><code>samples</code>: Vector holding posterior samples of model parameters.</li><li><code>model</code>: The model object to which samples were fit.</li><li><code>n_samples</code>: Total number of Monte Carlo samples. </li><li><code>non_burnin_ind</code>: Indices of non-burnin samples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L1-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.samples-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#BayesDensityCore.samples-Tuple{PosteriorSamples}"><code>BayesDensityCore.samples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">samples(ps::PosteriorSamples{T, V}) where {T, V&lt;:AbstractVector} -&gt; V</code></pre><p>Get the posterior samples of a <code>PosteriorSamples</code> object as a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L24-L28">source</a></section></details></article><p>The following methods can be used to extract useful information about the model object, such as the underlying model object and the number of samples.</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.model-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#BayesDensityCore.model-Tuple{PosteriorSamples}"><code>BayesDensityCore.model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">model(ps::PosteriorSamples) -&gt; AbstractBayesDensityModel</code></pre><p>Return the model object of <code>ps</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.n_samples-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#BayesDensityCore.n_samples-Tuple{PosteriorSamples}"><code>BayesDensityCore.n_samples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n_samples(ps::PosteriorSamples) -&gt; Int</code></pre><p>Get the total number of samples of a <code>PosteriorSamples</code> object, including burn-in samples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L31-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.n_burnin-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#BayesDensityCore.n_burnin-Tuple{PosteriorSamples}"><code>BayesDensityCore.n_burnin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n_burnin(ps::PosteriorSamples) -&gt; Int</code></pre><p>Get the number of burn-in samples of a <code>PosteriorSamples</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L38-L42">source</a></section></details></article><p>By default, <code>PosteriorSamples</code> objects also store the burn-in samples from the MCMC routine. These can be discarded via the following method:</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.drop_burnin-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#BayesDensityCore.drop_burnin-Tuple{PosteriorSamples}"><code>BayesDensityCore.drop_burnin</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drop_burnin(ps::PosteriorSamples{T}) where {T} -&gt; PosteriorSamples{T}</code></pre><p>Create a new <code>PosteriorSamples</code> object where the burn-in samples have been discarded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L68-L72">source</a></section></details></article><p>Multiple <code>PosteriorSamples</code> objects can also be concatenated to create a single <code>PosteriorSamples</code> object. This is particularly useful when a preliminary MCMC run is deemed to be too short, and one wants to pool the original samples with the samples from a new MCMC run.</p><article><details class="docstring" open="true"><summary id="Base.vcat-Tuple{Vararg{PosteriorSamples}}"><a class="docstring-binding" href="#Base.vcat-Tuple{Vararg{PosteriorSamples}}"><code>Base.vcat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vcat(ps::PosteriorSamples...) -&gt; PosteriorSamples</code></pre><p>Concatenate the samples of multiple <code>PosteriorSamples</code> objects to form a single object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L75-L79">source</a></section></details></article><h4 id="Computing-posterior-summary-statistics"><a class="docs-heading-anchor" href="#Computing-posterior-summary-statistics">Computing posterior summary statistics</a><a id="Computing-posterior-summary-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-posterior-summary-statistics" title="Permalink"></a></h4><p>When using Bayesian density estimators, we are often interested in computing various summary statistics of the posterior draws from an MCMC procedure. For instance, we may be interested in providing an estimate of the density <span>$f$</span> (e.g. the posterior mean) and to quantify the uncertainty in this estimate (e.g. via credible bands).</p><p>To this end, <code>BayesDensityCore</code> provides methods for <code>PosteriorSamples</code> objects that let us easily compute relevant summary statistics for the density <span>$f$</span>, as shown in the short example below:</p><pre><code class="language-julia hljs">bsm = BSplineMixture(randn(1000))
posterior = sample(bsm, 2000; n_burnin=400)

# Compute the posterior mean of f(0.5)
mean(posterior, pdf, 0.5)

# Compute the posterior 0.05 and 0.95-quantiles of f(0.5)
# Note that supplying pdf as the second argument is optional here
quantile(posterior, 0.5, [0.05, 0.95]) == quantile(posterior, pdf, 0.5, [0.05, 0.95])</code></pre><p>In some cases it may also be of interest to carry out posterior inference for the cumulative distribution function <span>$F(t) = \int_{-\infty}^t f(s)\, \text{d}s$</span>. Computing posterior summary statistics for the cdf instead of the pdf is easily achieved by replacing the <code>pdf</code> in the second argument with <code>cdf</code> instead:</p><pre><code class="language-julia hljs"># Compute the posterior mean of F(0.5)
mean(posterior, cdf, 0.5)

# Compute the posterior 0.05 and 0.95-quantiles of F(0.5)
# Note that supplying cdf as the second argument is necessary here
quantile(posterior, cdf, 0.5, [0.05, 0.95])</code></pre><p>The posterior summary statistics available through <code>BayesDensityCore</code> are the following:</p><article><details class="docstring" open="true"><summary id="Statistics.mean-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#Statistics.mean-Tuple{PosteriorSamples}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mean(
    ps::PosteriorSamples,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}}
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the approximate posterior mean of a functional of <span>$f$</span> for every element in the collection <code>t</code> using Monte Carlo samples.</p><p>The target functional can be either be the pdf <span>$f$</span> or the cdf <span>$F$</span>, and is controlled by adjusting the <code>func</code> argument. By default, the posterior mean of <span>$f$</span> is computed.</p><p>If the input <code>t</code> is a scalar, a scalar is returned. If <code>t</code> is a vector, this function returns a vector the same length as <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0, 1, 5001)) .^(1/3)).^(1/3);

julia&gt; ps = sample(Random.Xoshiro(1), BSplineMixture(x), 5000);

julia&gt; mean(ps, 0.1)
0.0969450407517681

julia&gt; mean(ps, [0.1, 0.8])
2-element Vector{Float64}:
 0.0969450407517681
 1.3662358915400654</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L210-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.quantile-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#Statistics.quantile-Tuple{PosteriorSamples}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quantile(
    ps::PosteriorSamples,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}},
    q::RealAbstractVector{&lt;:Real,
) -&gt; Union{Real, Vector{&lt;:Real}}

quantile(
    ps::PosteriorSamples,
    [func = pdf]
    t::Union{Real, AbstractVector{&lt;:Real}},
    q::AbstractVector{&lt;:Real},
) -&gt; Matrix{&lt;:Real}</code></pre><p>Compute the approximate posterior quantile(s) of a functional of <span>$f$</span> for every element in the collection <code>t</code> using Monte Carlo samples.</p><p>The target functional can be either be the pdf <span>$f$</span> or the cdf <span>$F$</span>, and is controlled by adjusting the <code>func</code> argument. By default, the posterior quantiles of <span>$f$</span> are computed.</p><p>In the case where both <code>t</code> and <code>q</code> are scalars, the output is a real number. When <code>t</code> is a vector and <code>q</code> a scalar, this function returns a vector of the same length as <code>t</code>. If <code>q</code> is supplied as a Vector, then this method returns a Matrix of dimension <code>(length(t), length(q))</code>, where each column corresponds to a given quantile. This is also the case when <code>t</code> is supplied as a scalar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0, 1, 5001)) .^(1/3)).^(1/3);

julia&gt; ps = sample(Random.Xoshiro(1), BSplineMixture(x), 5000);

julia&gt; quantile(ps, 0.1, 0.5); # Get the posterior median of f(0.5)

julia&gt; quantile(ps, cdf, 0.1, 0.5); # Get the posterior median of F(0.5)

julia&gt; quantile(ps, [0.1, 0.8], [0.05, 0.95]); # Get the posterior 0.05, 0.95-quantiles of f(0.1) and f(0.8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L128-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.median-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#Statistics.median-Tuple{PosteriorSamples}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">median(
    ps::PosteriorSamples,
    [func = pdf]
    t::Union{Real, AbstractVector{&lt;:Real}},
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the approximate posterior median of a functional of <span>$f$</span> for every element in the collection <code>t</code> using Monte Carlo samples.</p><p>The target functional can be either be the pdf <span>$f$</span> or the cdf <span>$F$</span>, and is controlled by adjusting the <code>func</code> argument. By default, the posterior median of <span>$f$</span> is computed.</p><p>If the input <code>t</code> is a scalar, a scalar is returned. If <code>t</code> is a vector, this function returns a vector the same length as <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L194-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.var-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#Statistics.var-Tuple{PosteriorSamples}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var(
    ps::PosteriorSamples,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}}
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the approximate posterior variance of a functional of <span>$f$</span> for every element in the collection <code>t</code> using Monte Carlo samples.</p><p>The target functional can be either be the pdf <span>$f$</span> or the cdf <span>$F$</span>, and is controlled by adjusting the <code>func</code> argument. By default, the posterior variance of <span>$f$</span> is computed.</p><p>If the input <code>t</code> is a scalar, a scalar is returned. If <code>t</code> is a vector, this function returns a vector the same length as <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0, 1, 5001)) .^(1/3)).^(1/3);

julia&gt; ps = sample(Random.Xoshiro(1), BSplineMixture(x), 5000);

julia&gt; var(ps, 0.1) # get the posterior variance of f(0.1)
0.00027756364767372627

julia&gt; var(ps, [0.1, 0.8]) # get the posterior variance of f(0.1) and f(0.8)
2-element Vector{Float64}:
 0.00027756364767372627
 0.005977674286240125</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L241-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.std-Tuple{PosteriorSamples}"><a class="docstring-binding" href="#Statistics.std-Tuple{PosteriorSamples}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">std(
    ps::PosteriorSamples,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}}
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the approximate posterior standard deviation of a functional of <span>$f$</span> for every element in the collection <code>t</code> using Monte Carlo samples.</p><p>The target functional can be either be the pdf <span>$f$</span> or the cdf <span>$F$</span>, and is controlled by adjusting the <code>func</code> argument. By default, the posterior standard deviation of <span>$f$</span> is computed.</p><p>If the input <code>t</code> is a scalar, a scalar is returned. If <code>t</code> is a vector, this function returns a vector the same length as <code>t</code>. This method is equivalent to <code>sqrt.(var(rng, vip, t, n_samples))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L272-L286">source</a></section></details></article><h2 id="Variational-inference"><a class="docs-heading-anchor" href="#Variational-inference">Variational inference</a><a id="Variational-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Variational-inference" title="Permalink"></a></h2><p>The <code>varinf</code> method can be used to compute a variational approximation to the posterior distribution:</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.varinf-Tuple{AbstractBayesDensityModel}"><a class="docstring-binding" href="#BayesDensityCore.varinf-Tuple{AbstractBayesDensityModel}"><code>BayesDensityCore.varinf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">varinf(
    bdm::AbstractBayesDensityModel{T},
    args...;
    kwargs...
) where {T}</code></pre><p>Compute a variational approximation to the posterior distribution.</p><p>The positional arguments and keyword arguments supported by this function, as well as the type of the returned variational posterior object differs between different subtypes of <a href="#BayesDensityCore.AbstractBayesDensityModel"><code>AbstractBayesDensityModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L1-L11">source</a></section></details></article><p>Any call to <code>varinf</code> will return a subtype of the abstract type <code>AbstractVIPosterior</code>:</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.AbstractVIPosterior"><a class="docstring-binding" href="#BayesDensityCore.AbstractVIPosterior"><code>BayesDensityCore.AbstractVIPosterior</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractVIPosterior{T&lt;:Real}</code></pre><p>Abstract super type representing the variational posterior distribution of <code>AbstractBayesDensityModel</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L14-L18">source</a></section></details></article><p>For most models, <code>varinf</code> also returns an object which stores the result of the optimization procedure, see <a href="#BayesDensityCore.VariationalOptimizationResult"><code>VariationalOptimizationResult</code></a>.</p><p>The following convenience methods are also part of the public API:</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.model-Tuple{AbstractVIPosterior}"><a class="docstring-binding" href="#BayesDensityCore.model-Tuple{AbstractVIPosterior}"><code>BayesDensityCore.model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">model(vip::AbstractVIPosterior{T}) where {T} -&gt; AbstractBayesDensityModel{T}</code></pre><p>Get the model object to which the variational posterior <code>vip</code> was fitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L48-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.eltype-Tuple{AbstractVIPosterior}"><a class="docstring-binding" href="#Base.eltype-Tuple{AbstractVIPosterior}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">eltype(::AbstractBayesDensityModel{T}) where {T}</code></pre><p>Return the element type of a Bayesian density model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/BayesDensityCore.jl#L24-L28">source</a></section><section><div><pre><code class="language-julia hljs">eltype(::PosteriorSamples{T}) where {T}</code></pre><p>Get the element type of a <code>PosteriorSamples</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/monte_carlo.jl#L52-L56">source</a></section><section><div><pre><code class="language-julia hljs">eltype(::AbstractVIPosterior{T}) where {T}</code></pre><p>Get the element type of a variational posterior object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L21-L25">source</a></section></details></article><h4 id="Generating-samples-from-the-variational-posterior"><a class="docs-heading-anchor" href="#Generating-samples-from-the-variational-posterior">Generating samples from the variational posterior</a><a id="Generating-samples-from-the-variational-posterior-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-samples-from-the-variational-posterior" title="Permalink"></a></h4><p>The <code>sample</code> method makes it possible to generate independent samples from the variational posterior. This is particularly useful in cases where inference for multiple posterior quantities (e.g. medians, variances) is desired.</p><article><details class="docstring" open="true"><summary id="StatsBase.sample-Tuple{AbstractVIPosterior, Int64}"><a class="docstring-binding" href="#StatsBase.sample-Tuple{AbstractVIPosterior, Int64}"><code>StatsBase.sample</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample(
    [rng::Random.AbstractRNG],
    vip::AbstractVIPosterior{T},
    n_samples::Int
) where {T} -&gt; PosteriorSamples{T}</code></pre><p>Generate <code>n_samples</code> independent samples from the variationonal posterior distribution <code>vip</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0, 1, 5001)) .^(1/3)).^(1/3);

julia&gt; vip = varinf(BSplineMixture(x));

julia&gt; vps = sample(Random.Xoshiro(1812), vip, 5000);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L28-L45">source</a></section></details></article><p>As shown in the above docstring, using the <code>sample</code> method on a <code>AbstractVIPosterior</code> object returns an object of type <a href="#BayesDensityCore.PosteriorSamples"><code>PosteriorSamples</code></a>. As such, all of the convenience methods showcased in the previous subsection will also work for the object returned by <code>sample</code>.</p><h4 id="Computing-posterior-summary-statistics-2"><a class="docs-heading-anchor" href="#Computing-posterior-summary-statistics-2">Computing posterior summary statistics</a><a class="docs-heading-anchor-permalink" href="#Computing-posterior-summary-statistics-2" title="Permalink"></a></h4><p><code>BayesDensityCore</code> also provides convenience methods for <code>AbstractVIPosterior</code> objects that let us easily compute relevant summary statistics for the density <span>$f$</span> and the cdf <span>$F$</span> directly from the variational posterior object:</p><pre><code class="language-julia hljs">bsm = BSplineMixture(randn(1000))
viposterior, info = varinf(bsm)

# Compute the (variational) posterior mean of f(0.5)
mean(viposterior, pdf, 0.5)

# Compute the (variational) posterior median of F(0.5)
median(viposterior, cdf, 0.5)

# Compute the (variational) posterior 0.05 and 0.95-quantiles of f(0.5)
# Note that supplying pdf as the second argument is optional here
quantile(viposterior, 0.5, [0.05, 0.95]) ≈ quantile(viposterior, pdf, 0.5, [0.05, 0.95])</code></pre><p>The full list of available summary statistics is the same as that for <code>PosteriorSamples</code> objects:</p><article><details class="docstring" open="true"><summary id="Statistics.mean-Tuple{AbstractVIPosterior}"><a class="docstring-binding" href="#Statistics.mean-Tuple{AbstractVIPosterior}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mean(
    [rng::Random.AbstractRNG],
    vip::AbstractVIPosterior,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}},
    [n_samples::Int=1000]
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the approximate posterior mean of <span>$f(t)$</span> for every element in the collection <code>t</code> using Monte Carlo samples.</p><p>If the input <code>t</code> is a scalar, a scalar is returned. If <code>t</code> is a vector, this function returns a vector the same length as <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0, 1, 5001)) .^(1/3)).^(1/3);

julia&gt; vip = varinf(BSplineMixture(x));

julia&gt; mean(Random.Xoshiro(1), vip, 0.1)
0.08615412808594237

julia&gt; mean(Random.Xoshiro(1), vip, [0.1, 0.8])
2-element Vector{Float64}:
 0.08615412808594237
 1.3674886390998342</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L129-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.quantile-Tuple{AbstractVIPosterior}"><a class="docstring-binding" href="#Statistics.quantile-Tuple{AbstractVIPosterior}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quantile(
    [rng::Random.AbstractRNG],
    vip::AbstractVIPosterior,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}},
    q::Union{Real, AbstractVector{&lt;:Real}},
    [n_samples::Int=1000]
) -&gt; Union{Real, Vector{&lt;:Real}}

quantile(
    [rng::Random.AbstractRNG],
    vip::AbstractVIPosterior,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}},
    q::AbstractVector{&lt;:Real},
    [n_samples::Int=1000]
) -&gt; Matrix{&lt;:Real}</code></pre><p>Compute the posterior <code>q</code>-quantile(s) of the pdf <span>$f(t)$</span> or the cdf <span>$F(t)$</span> for each element in the collection <code>t</code>.</p><p>By default this function falls back to <code>quantile(sample(rng, vip, n_samples), func, t, q)</code></p><p>In the case where both <code>t</code> and <code>q</code> are scalars, the output is a real number. When <code>t</code> is a vector and <code>q</code> a scalar, this function returns a vector of the same length as <code>t</code>. If <code>q</code> is supplied as a Vector, then this function returns a Matrix of dimension <code>(length(t), length(q))</code>, where each column corresponds to a given quantile. This is also the case when <code>t</code> is supplied as a scalar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0, 1, 5001)) .^(1/3)).^(1/3);

julia&gt; vip = varinf(BSplineMixture(x));

julia&gt; quantile(Random.Xoshiro(1), vip, 0.9, 0.5)
0.537450082172813

julia&gt; quantile(Random.Xoshiro(1), vip, [0.2, 0.8], [0.05, 0.95])
2×2 Matrix{Float64}:
 0.34042  0.362478
 1.3039   1.43599</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L55-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.median-Tuple{AbstractVIPosterior}"><a class="docstring-binding" href="#Statistics.median-Tuple{AbstractVIPosterior}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">median(
    [rng::Random.AbstractRNG],
    vip::AbstractVIPosterior,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}},
    [n_samples::Int=1000]
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the posterior median of the pdf <span>$f(t)$</span> or the cdf <span>$F(t)$</span> for each element in the collection <code>t</code>.</p><p>Equivalent to <code>quantile(rng, vip, t, 0.5, n_samples)</code>.</p><p>In the case where both <code>t</code> and <code>q</code> are scalars, the output is a real number. When <code>t</code> is a vector, this function returns a vector of the same length as <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L111-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.var-Tuple{AbstractVIPosterior}"><a class="docstring-binding" href="#Statistics.var-Tuple{AbstractVIPosterior}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var(
    [rng::Random.AbstractRNG],
    vip::AbstractVIPosterior,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}},
    [n_samples::Int=1000]
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the posterior variance of the pdf <span>$f(t)$</span> or the cdf <span>$F(t)$</span> for each element in the collection <code>t</code>.</p><p>If the input <code>t</code> is a scalar, a scalar is returned. If <code>t</code> is a vector, this function returns a vector the same length as <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (1.0 .- (1.0 .- LinRange(0, 1, 5001)) .^(1/3)).^(1/3);

julia&gt; vip = varinf(BSplineMixture(x));

julia&gt; var(Random.Xoshiro(1), vip, 0.1)
3.2895012264929507e-6

julia&gt; var(Random.Xoshiro(1), vip, [0.1, 0.8])
2-element Vector{Float64}:
 3.2895012264929507e-6
 0.0014793006688108977</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L159-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.std-Tuple{AbstractVIPosterior}"><a class="docstring-binding" href="#Statistics.std-Tuple{AbstractVIPosterior}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">std(
    [rng::Random.AbstractRNG],
    vip::AbstractVIPosterior,
    [func = pdf],
    t::Union{Real, AbstractVector{&lt;:Real}},
    [n_samples::Int=1000]
) -&gt; Union{Real, Vector{&lt;:Real}}</code></pre><p>Compute the posterior standard deviation of the pdf <span>$f(t)$</span> or the cdf <span>$F(t)$</span> for each element in the collection <code>t</code>.</p><p>If the input <code>t</code> is a scalar, a scalar is returned. If <code>t</code> is a vector, this function returns a vector the same length as <code>t</code>. This method is equivalent to <code>sqrt.(var(rng, vip, t, n_samples))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L189-L202">source</a></section></details></article><div class="admonition is-info" id="Note-8c041c83000f1fb0"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-8c041c83000f1fb0" title="Permalink"></a></header><div class="admonition-body"><p>Note that each call to <code>mean</code>, <code>quantile</code>, <code>median</code>, <code>var</code> or <code>std</code> in most cases will first simulate a random sample from the posterior distribution, and then uses this sample to compute a Monte Carlo approximation of the quantity of interest using these samples. If posterior inference for multiple quantities is desired, then it is recommended to first use <a href="#StatsBase.sample-Tuple{AbstractBayesDensityModel, Int64}"><code>sample</code></a>, and call these functions on this object as only a single batch of posterior samples is generated in this case.</p></div></div><h4 id="Storing-info-from-the-variational-optimization"><a class="docs-heading-anchor" href="#Storing-info-from-the-variational-optimization">Storing info from the variational optimization</a><a id="Storing-info-from-the-variational-optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Storing-info-from-the-variational-optimization" title="Permalink"></a></h4><p>In order to provide a simple way of performing convergence diagnostics for variational optimization problems, <code>BayesDensityCore</code> exports the <a href="#BayesDensityCore.VariationalOptimizationResult"><code>VariationalOptimizationResult</code></a> type.</p><article><details class="docstring" open="true"><summary id="BayesDensityCore.VariationalOptimizationResult"><a class="docstring-binding" href="#BayesDensityCore.VariationalOptimizationResult"><code>BayesDensityCore.VariationalOptimizationResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VariationalOptimizationResult{T&lt;:Real}</code></pre><p>Struct holding the result of a variational inference procedure.</p><p><strong>Fields</strong></p><ul><li><code>ELBO</code>: The values of the evidence lower bound per iteration.</li><li><code>converged</code>: Boolean flag indicating whether the optimization was succesful or not.</li><li><code>n_iter</code>: Number of iterations run before termination.</li><li><code>tolerance</code>: Tolerance parameter used to determine convergence.</li><li><code>variational_posterior</code>: The fitted variational posterior distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L221-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.elbo"><a class="docstring-binding" href="#BayesDensityCore.elbo"><code>BayesDensityCore.elbo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">elbo(varoptinf::VariationalOptimizationResult{T}) where {T} -&gt; Vector{T}</code></pre><p>Get the value of the evidence lower bound for each iteration of the optimization procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L274-L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.n_iter"><a class="docstring-binding" href="#BayesDensityCore.n_iter"><code>BayesDensityCore.n_iter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">n_iter(varoptinf::VariationalOptimizationResult{T}) where {T} -&gt; Int</code></pre><p>Get the number of iterations used to fit the variational posterior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L267-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.converged"><a class="docstring-binding" href="#BayesDensityCore.converged"><code>BayesDensityCore.converged</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">converged(varoptinf::VariationalOptimizationResult{T}) where {T} -&gt; Bool</code></pre><p>Return the convergence status of the variational optimization as a bool.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L281-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.tolerance"><a class="docstring-binding" href="#BayesDensityCore.tolerance"><code>BayesDensityCore.tolerance</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tolerance(varoptinf::VariationalOptimizationResult{T}) where {T} -&gt; T</code></pre><p>Get the value of the tolerance level used to determine convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L288-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="BayesDensityCore.posterior"><a class="docstring-binding" href="#BayesDensityCore.posterior"><code>BayesDensityCore.posterior</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">posterior(varoptinf::VariationalOptimizationResult{T}) where {T} -&gt; AbstractVIPosterior{T}</code></pre><p>Get the fitted variational posterior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oskarhs/BayesDensity.jl/blob/f257f91efa6162f7780a372e3c3ff3335c90d1eb/lib/BayesDensityCore/src/variational.jl#L260-L264">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../density_estimation_primer/">« A primer on Bayesian nonparametric density estimation</a><a class="docs-footer-nextpage" href="../plotting_api/">Plotting API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 07:27">Tuesday 10 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
